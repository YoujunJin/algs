第二章 排序
2.1 初级排序算法
  1、游戏规则
  实现一个模板类，包含sort，less，exch，isSorted方法，输入数组中两个元素用less比较，然后用exch交换，在sort中调用，验证是为谨慎起见isSorted。
  ·验证
  ·运行时间：排序成本模型，在研究排序算法时，需要计算比较和交换的数量，对于不交换元素的算法，我们会计算访问数组的次数。
  ·额外的内存使用：排序算法可以分为两类，除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法，以及需要额外内存空间来存储另一份数组副本的其他排序算法。
  ·数据类型：Java中封装的数字类型（Int，Double）或String和其他高级数据类型（File和URL）都实现了Comparable接口，自定义数据类型要实现接口Comparable的函数compareTo。
  2、选择排序
  双层循环，内层找当前位置以后最小的，外层交换最小的和当前位置。
  因为在不断选择生于元素之中最小者，所以叫选择排序。
  选择排序的性质是运行时间和输入无关，即使是排好序的或相同值得数组也要平方级的时间；数据移动是最少的，数据交换与输入规模线性关系。
  3、插入排序
  从第一个元素开始（0开始），内层循环把它与前面的元素比较，把比它大的元素向后移一位，可以不总是exch，对于部分有序数组处理速度快。
  很多高级排序算法的中间过程
  4、排序算法的可视化
  棒状图
  5、比较两种排序算法
  计时验证猜想，猜想通过分析访问数组次数得到。
  6、希尔排序
  一种基于插入排序的快速的排序算法。
  对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，
  希尔排序为了加快速度简单改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将部分有序数组排序。
  简单的希尔排序，在插入排序中加入一个外循环来将h按照递增序列（1，h1，h2，h3）递减（h3，h2，h1，1），内部插入排序的处理元素是h间隔的子数组，通过多次插入排序，一次次把乱序数组变成部分有序数组（h间隔）最终排好序。
  它的性能最重要的结论是它的运行时间达不到平方级别，但是具体视情况而定。
  对于中等大小的复杂数组它的运行时间是可以接受的。
  希尔排序非常有用，很多时候可以先使用它。
2.2 归并排序
  归并：将两个有序的数组归并成一个更大的有序数组。将一个数组排序，可以（递归地）将它分成两半分别排序，然后将结果归并起来。
  最吸引人的优点：它能够保证将任意长度为N的数组排序所需时间和NlogN成正比。
  主要缺点：它需要的额外空间和N成正比。
  1、原地归并的抽象方法
  最直截了当的归并是创建一个适当大小的新数组，然后把两个有序数组的元素一个个比较后放入新数组，但是每次递归都创建新数组会带来问题。
  书上还是有辅助数组啊，怎么是原地呢？原来是一次性分配数组，不需要每次创建适当大小的数组。
  2、自顶向下的归并排序
  书上就是创建了一个和原数组一样大小的辅助数组，分成两半（递归地）用辅助数组保存原值，然后两半分别从自己的第一个元素开始比较，然后归并回原数组。
  归并排序用树状图来理解，N = 2^n个元素的数组用树分段高度为n=lgN层，每层k，有2^k个子数组，每个数组长度为2^(n-k)（最多比较次数），所以每层比较2^n次，总共n*2^n = NlgN.
  改进：
  ·对于元素个数小于一定个数的子数组（比如长度小于15）使用其他如插入排序（选择排序）的排序方法，减少频繁的递归调用。
  ·添加条件，如果两部分都排好序后，比较a[mid]<=a[mid+1]，就不用merge了，这样对于任意有序的子数组算法运行时间变为线性。
  3、自底向上的归并排序
  子数组大小从1逐渐翻倍到全部数组元素都访问到。
2.3 快速排序
  实现简单，适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。
  应用最广泛，原地排序（只需要一个很小的辅助栈），Onlgn。
  1、基本算法
  分治的排序算法。将一个数组分成两个子数组，将两部分独立的排序。
  和归并排序是互补的，归并把两个子数组分别排序然后归并。而快速排序当子数组都有序时整个数组自然有序了。
  归并排序是分成两半，快排的切分位置取决于数组内容。
  实现时先确定切分位置，使切分后的数组满足
  ·切分位置j，a[j]已经排定，
  ·a[lo]到a[j-1]中的所有元素都不大于a[j]
  ·a[j+1]到a[hi]中的所有元素都不小于a[j]。
  然后递归调用把切分位置左侧和右侧继续排序。
  寻找切分位置就是对要切分的数组同时从左到右和从右到左扫描，左侧发现比a[j]大的停止，右侧发现比a[j]小的停止，然后如果两个指针相遇就把a[j]放在这，否则交换两个值后继续直到相遇。
  原地切分：这种先找到位置再交换或者赋值的方法就是原地了，用辅助数组还要循环复制回去开销更大。
  保持随机性：一是顺序打乱，二是随机选择切分元素，随机性对于预测算法的运行时间重要？
  改进：
  ·在小的子数组上切换到插入排序
  ·三采样切分：取3个样本的中位数来切分
  ·熵最优的排序：三向切分的快速排序
2.4 优先队列
  优先队列是一种抽象数据类型，它表示一组值和对这些值得操作，堆排序算法也来自于基于堆的优先队列的实现。
  1、API
  它的最重要的操作就是删除最大元素和插入元素，
  有最大优先队列MaxPQ,最小优先队列MinPQ，都实现了删除并返回最大（或最小）键值的元素。
  应用场景：在输入N非常大的时候，从中找出最大（或最小）的M个元素，由于N超大把输入先排序和把新的输入与已知的M个最大元素比较带来的代价非常高昂。所以用优先队列高效的实现insert和delMin解决这个问题。
  排序算法时间复杂度NlogN底限，空间复杂度N，调用初级实现的优先队列时间复杂度NM，空间复杂度M，调用基于堆实现的优先队列堆排序时间复杂度NlogM,空间复杂度M。
  2、初级实现
  ·数组实现（无序）：和数组实现栈的代码差不多，无序的插入方法和push方法一样，delMax方法需要在pop方法里添加一个内循环将最大元素和边界元素交换然后删除，数组也可以动态调整大小。
  ·数组实现（有序）：del方法不变，insert方法中添加将所有较大的元素向右移动一格，像插入排序一样。
  ·链表实现：和数组相似。
  3、堆的定义
  数据结构二叉堆能够很好地实现优先队列的基本操作。
  在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。这两个特定位置的元素也要至少大于等于数组中的另两个元素，以此类推，可以将所有元素画成一棵二叉树。
  当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。
  完全二叉树，除了叶子结点，每个结点都有两个子结点。完全二叉树只用数组而不需要指针就可以表示，具体方法就是将二叉树的结点按照层级顺序放入数组中。
  二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。
  数组实现的二叉堆（下文简称堆）可以无需指针在树中移动，实现了对数级别的算法复杂度。
  4、堆的算法
  ·堆用数组就可以实现，
  ·堆的操作（如插入和删除）会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。这个过程叫做堆的有序化。
  ·堆实现的比较和交换方法是通过数组中两个位置的索引操作的。
  ·当某个结点的优先级上升，如在堆底加入一个新的元素，需要由下至上恢复堆的顺序。新值像气泡上浮一样，与比它小的父结点交换，直到上浮到堆恢复有序，方法名就叫swim，交换k和父结点k/2.
  ·当某个结点的优先级下降，如将根结点替换为一个较小的元素时，需要由上至下恢复堆的顺序。把这个值和子结点中较大的交换，就像下沉一样直到沉到堆恢复有序，方法名就叫sink，
  ·插入元素：将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。
  ·删除最大元素：从数组顶端删除最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。
  ·基于堆结构实现优先队列，能够保证插入元素和删除最大元素用时和队列的大小成对数关系。插入新元素，就在堆数组最后加入，然后swim上浮，删除最大（最小，取决于堆的性质）元素就把根结点删除同时交换最后一个元素，然后sink下沉，由于二叉树的性质，从根结点到叶子结点的长度不超过lgN，所以无论插入操作和删除操作都在对数时间内。
  ·多叉堆：基于数组表示的完全三叉树（只是数组空间要保留，不一定3个孩子都有值）构造堆，k结点的子结点是3k-1，3k和3k+1，父结点是(k+1)/3，当叉变多也能，但是需要在树高log d N 和在每个结点的d个子结点中找到最大者的代价之间权衡。
  ·调整数组大小：在insert函数中添加将数组长度加倍的代码，在delMax函数中添加将数组长度减半的代码，让使用率不低于1/4
  ·元素的不可变性：优先队列存储了用例创建的对象，但同时假设用例代码不会改变它们，需要注意的是，程序员一般不会将这个假设转化为强制条件，因为增加代码的复杂度影响性能。
  ·索引优先队列：插入优先队列的元素可以被设置一个索引，这个索引可以有很多用途，如使用索引优先队列的多向归并排序，3个（或很多个）有序数组去归并排序，把每个数组的第一个插入到优先队列里并分配一个索引指向自己所在的数组，就可以先删除优先队列最小的值，然后用它的索引再插入其索引对应数组的下一个元素（优先队列插入就已经排序了），这样全部都能有序输出了。
  5、堆排序
  任意优先队列可以变成一种排序方法，如MinPQ，如果用无序数组实现，删除最小元素相当于用了一次选择排序？（书上说插入排序，但是有序数组才是插入排序吧）。
  如果用基于堆的优先队列这样做就是一个全新的排序算法——堆排序。
  堆排序可以分为两个阶段：
  ·构造阶段，将原始数组重新组织安排进一个堆里。
  ·下沉排序阶段，从堆中按递减顺序取出所有元素并得到排序结果。
  堆的构造：使用下沉函数构造子堆，从N/2位置开始下沉排序，直到从根结点的元素下沉，堆有序。
  堆排序算法：
  ·下沉排序，把根结点元素和最后一个元素交换位置并输出根结点元素同时删除，然后从根结点开始下沉排序。最坏时间复杂度也是2NlgN
  ·先下沉再上浮，在下沉时不判断子结点和它的大小，总是直接提升较大子结点，让它沉到堆底，然后再使其上浮到正确的位置，这种方法可以将比较次数减少一半，因为下沉时每一步都要比较两次，而上浮只要1次
  堆排序在排序复杂性的研究中有着重要的地位，因为它是我们所知的唯一能够同时最优地利用空间和时间的方法——在最坏情况下它也能保证使用~2NlgN次比较和恒定的额外空间。
  但是堆排序对于缓存的利用降低，因为它很少跟相邻元素去比较，缓存未命中次数高。
  基于堆的优先队列很重要。
2.5 应用
  排序算法和优先队列在许多场景中有着广泛的应用。
  排序如此有用的一个主要原因是，在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单得多。
  
