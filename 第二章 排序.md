第二章 排序
2.1 初级排序算法
  1、游戏规则
  实现一个模板类，包含sort，less，exch，isSorted方法，输入数组中两个元素用less比较，然后用exch交换，在sort中调用，验证是为谨慎起见isSorted。
  ·验证
  ·运行时间：排序成本模型，在研究排序算法时，需要计算比较和交换的数量，对于不交换元素的算法，我们会计算访问数组的次数。
  ·额外的内存使用：排序算法可以分为两类，除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法，以及需要额外内存空间来存储另一份数组副本的其他排序算法。
  ·数据类型：Java中封装的数字类型（Int，Double）或String和其他高级数据类型（File和URL）都实现了Comparable接口，自定义数据类型要实现接口Comparable的函数compareTo。
  2、选择排序
  双层循环，内层找当前位置以后最小的，外层交换最小的和当前位置。
  因为在不断选择生于元素之中最小者，所以叫选择排序。
  选择排序的性质是运行时间和输入无关，即使是排好序的或相同值得数组也要平方级的时间；数据移动是最少的，数据交换与输入规模线性关系。
  3、插入排序
  从第一个元素开始（0开始），内层循环把它与前面的元素比较，把比它大的元素向后移一位，可以不总是exch，对于部分有序数组处理速度快。
  很多高级排序算法的中间过程
  4、排序算法的可视化
  棒状图
  5、比较两种排序算法
  计时验证猜想，猜想通过分析访问数组次数得到。
  6、希尔排序
  一种基于插入排序的快速的排序算法。
  对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，
  希尔排序为了加快速度简单改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将部分有序数组排序。
  简单的希尔排序，在插入排序中加入一个外循环来将h按照递增序列（1，h1，h2，h3）递减（h3，h2，h1，1），内部插入排序的处理元素是h间隔的子数组，通过多次插入排序，一次次把乱序数组变成部分有序数组（h间隔）最终排好序。
  它的性能最重要的结论是它的运行时间达不到平方级别，但是具体视情况而定。
  对于中等大小的复杂数组它的运行时间是可以接受的。
  希尔排序非常有用，很多时候可以先使用它。
2.2 归并排序
  归并：将两个有序的数组归并成一个更大的有序数组。将一个数组排序，可以（递归地）将它分成两半分别排序，然后将结果归并起来。
  最吸引人的优点：它能够保证将任意长度为N的数组排序所需时间和NlogN成正比。
  主要缺点：它需要的额外空间和N成正比。
  1、原地归并的抽象方法
  最直截了当的归并是创建一个适当大小的新数组，然后把两个有序数组的元素一个个比较后放入新数组，但是每次递归都创建新数组会带来问题。
  书上还是有辅助数组啊，怎么是原地呢？原来是一次性分配数组，不需要每次创建适当大小的数组。
  2、自顶向下的归并排序
  书上就是创建了一个和原数组一样大小的辅助数组，分成两半（递归地）用辅助数组保存原值，然后两半分别从自己的第一个元素开始比较，然后归并回原数组。
  归并排序用树状图来理解，N = 2^n个元素的数组用树分段高度为n=lgN层，每层k，有2^k个子数组，每个数组长度为2^(n-k)（最多比较次数），所以每层比较2^n次，总共n*2^n = NlgN.
  改进：
  ·对于元素个数小于一定个数的子数组（比如长度小于15）使用其他如插入排序（选择排序）的排序方法，减少频繁的递归调用。
  ·添加条件，如果两部分都排好序后，比较a[mid]<=a[mid+1]，就不用merge了，这样对于任意有序的子数组算法运行时间变为线性。
  3、自底向上的归并排序
  子数组大小从1逐渐翻倍到全部数组元素都访问到。
2.3 快速排序
  实现简单，适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。
  应用最广泛，原地排序（只需要一个很小的辅助栈），Onlgn。
  1、基本算法
  分治的排序算法。将一个数组分成两个子数组，将两部分独立的排序。
  和归并排序是互补的，归并把两个子数组分别排序然后归并。而快速排序当子数组都有序时整个数组自然有序了。
  归并排序是分成两半，快排的切分位置取决于数组内容。
  实现时先确定切分位置，使切分后的数组满足
  ·切分位置j，a[j]已经排定，
  ·a[lo]到a[j-1]中的所有元素都不大于a[j]
  ·a[j+1]到a[hi]中的所有元素都不小于a[j]。
  然后递归调用把切分位置左侧和右侧继续排序。
  寻找切分位置就是对要切分的数组同时从左到右和从右到左扫描，左侧发现比a[j]大的停止，右侧发现比a[j]小的停止，然后如果两个指针相遇就把a[j]放在这，否则交换两个值后继续直到相遇。
  原地切分：这种先找到位置再交换或者赋值的方法就是原地了，用辅助数组还要循环复制回去开销更大。
  保持随机性：一是顺序打乱，二是随机选择切分元素，随机性对于预测算法的运行时间重要？
  改进：
  ·在小的子数组上切换到插入排序
  ·三采样切分：取3个样本的中位数来切分
  ·熵最优的排序：三向切分的快速排序
2.4 优先队列
  优先队列是一种抽象数据类型，它表示一组值和对这些值得操作，堆排序算法也来自于基于堆的优先队列的实现。
  1、API
  它的最重要的操作就是删除最大元素和插入元素，
  有最大优先队列MaxPQ,最小优先队列MinPQ，都实现了删除并返回最大（或最小）键值的元素。
  应用场景：在输入N非常大的时候，从中找出最大（或最小）的M个元素，由于N超大把输入先排序和把新的输入与已知的M个最大元素比较带来的代价非常高昂。所以用优先队列高效的实现insert和delMin解决这个问题。
  排序算法时间复杂度NlogN底限，空间复杂度N，调用初级实现的优先队列时间复杂度NM，空间复杂度M，调用基于堆实现的优先队列堆排序时间复杂度NlogM,空间复杂度M。
  2、初级实现
  ·数组实现（无序）：和数组实现栈的代码差不多，无序的插入方法和push方法一样，delMax方法需要在pop方法里添加一个内循环将最大元素和边界元素交换然后删除，数组也可以动态调整大小。
  ·数组实现（有序）：del方法不变，insert方法中添加将所有较大的元素向右移动一格，像插入排序一样。
  ·链表实现：和数组相似。
  3、堆的定义
  数据结构二叉堆能够很好地实现优先队列的基本操作。
  在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。这两个特定位置的元素也要至少大于等于数组中的另两个元素，以此类推，可以将所有元素画成一棵二叉树。
  当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。
  完全二叉树，除了叶子结点，每个结点都有两个子结点。完全二叉树只用数组而不需要指针就可以表示，具体方法就是将二叉树的结点按照层级顺序放入数组中。
  二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。
  数组实现的二叉堆（简称堆）可以无需指针在树中移动，实现了对数级别的算法复杂度。
  4、堆的算法
  
